#if 0
#include <stdio.h>

#define nodes 35			// 전체 노드 수
#define class 5				// 전체 클래스 수 ( 자음 5개, 'ㄱ', 'ㄴ', 'ㄹ', 'ㅋ', 'ㅍ' )
#define patterns 10			// 입력 패턴 개수
#define lines 5				// 함수 사용과 출력의 편의를 위해 임의로 설정한 줄 수 입니다
							// ex) 35 노드 = 7 노드 x 5 lines

int CalOutPat(int [][nodes], int [][nodes], int [][nodes]);		// OutPatterns 계산 ( 모든 입력 패턴에 대해 1번씩 출력 패턴 계산 )
int CalOutPat2(int[][nodes], int i, int[nodes], int[][nodes]);	// OutPatterns 계산 ( i번째 입력 패턴에 대해서만 출력 패턴 계산 )
int CheckOutPat(int [][nodes], int i, int [][nodes]);			// OutPatterns 검사 ( 출력 패턴 수렴하는지 검사 )
void SetOutPat(int [][nodes], int i);							// OutPatterns 초기화 ( 하드 리미팅 비선형 활성화 함수 대응 )

int main()
{
	// ㄱ ㄴ ㄹ ㅋ ㅍ 에 대한 5개의 클래스 지정
	int S[class][nodes] =
	{
#if 1
		// ㄱ
		{
			 1,	 1,	 1,	 1,  1,	 1,	 1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1
		},
#endif

#if 1
		// ㄴ
		{
			 1,	-1,	-1,	-1, -1,	-1,	-1,
			 1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	 1,	 1,	 1,	 1,	 1,  1
		},
#endif

#if 1
		// ㄹ
		{
			 1,	 1,	 1,	 1,  1,	 1,	 1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
			 1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	 1,	 1,	 1,	 1,	 1,  1
		},
#endif

#if 0
		// ㅁ
		{
			 1,	 1,	 1,	 1,  1,	 1,	 1,
			 1,	-1,	-1,	-1,	-1,	-1,  1,
			 1,	-1,	-1,	-1,	-1,	-1,  1,
			 1,	-1,	-1,	-1,	-1,	-1,  1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
		},
#endif

#if 0
		// ㅅ
		{
			-1,	-1,	-1, -1, -1,	-1,	-1,
			-1,	-1,	-1,	 1,	-1,	-1, -1,
			-1,	-1,	 1,	-1,	 1,	-1, -1,
			-1,	 1,	-1,	-1,	-1,	 1, -1,
			 1,	-1,	-1,	-1,	-1,	-1,  1,
		},
#endif

#if 1
		// ㅋ
		{
			 1,	 1,	 1,	 1,  1,	 1,	 1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1
		},
#endif

#if 0
		// ㅌ
		
		{
			 1,	 1,	 1,	 1,  1,	 1,	 1,
			 1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
			 1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	 1,	 1,	 1,	 1,	 1,  1
		},
#endif		

#if 1
		// ㅍ
		{
			 1,	 1,	 1,	 1,  1,	 1,	 1,
			-1,	 1,	 1,	-1,	 1,	 1, -1,
			-1,	 1,	 1,	-1,	 1,	 1, -1,
			-1,	 1,	 1,	-1,	 1,	 1, -1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
		}
#endif
	};

	// class 출력 코드
	for (int k = 0; k < lines; k++)
	{
		for (int i = 0; i < class; i++)
		{
			int j = k * (nodes/lines);
			do
			{
				if (S[i][j] == 1)
					printf("■");
				else
					printf("□");
				j++;
			} while (j % (nodes / lines) != 0);
			printf("   ");
		}
		printf("\n");
	}

	
	// W (가중치) 계산 !
	// W1 ~ W5를 구하기 위해 S(i)^T * S(i) - I 계산
	int Wi[class][nodes][nodes] = { 0 };
	int W[nodes][nodes] = { 0 };

	for (int i = 0; i < class; i++)
	{
		for (int j = 0; j < nodes; j++)
		{
			for (int k = 0; k < nodes; k++)
			{										// S^T (트랜스포즈) * S 계산에 대해서,
				Wi[i][j][k] = S[i][j] * S[i][k];	// i번째 클래스에 대한 j행 k열의 W(가중치) 계산은
			}										// S^T 배열의 (j행 x 1열) x S 배열의 (1행 x k열) 입니다. 
													// 여기서, S^T 배열을 만드는 대신 기존 S행렬에 대해서
													// 대응되는 값만 대입해주면 되기에 왼쪽과 같은 코드로 구현하였습니다.

			Wi[i][j][j] -= 1;						// 배열의 [j][j] 번째 index 값을 1씩 빼줍니다
		}											// 즉, - I (단위행렬)를 수행합니다
	}

	for (int i = 0; i < class; i++)
	{
		for (int j = 0; j < nodes; j++)
		{
			for (int k = 0; k < nodes; k++)
			{										// 모든 클래스로 부터 산출된 가중치 값을 각각 더해서 
				W[j][k] += Wi[i][j][k];				// 최종 가중치를 계산합니다.
			}
		}
	}

# if 1
	// 가중치 출력 코드
	printf("\n");
	for (int j = 0; j < nodes; j++)
	{
		for (int k = 0; k < nodes; k++)
		{
			printf("%3d ", W[j][k]);
		}
		printf("\n");
	}
	printf("\n");
#endif

	// 입력 패턴
	int InPat[patterns][nodes] = {

		// [1] ㄱ 과 흡사한 패턴
		{
			 1,	 1,	 1,	-1,  1,	 1,	 1,
			 1,	-1,	-1,	-1,	-1,	 1, -1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1
		},

		// [2] ㄱ 과 흡사한 패턴
		{
			 1,	 1,	-1,	 1,  1,	 1,	 1,
			 1,	 1,	 1,	-1,	 1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1
		},

		// [3] ㄴ 과 흡사한 패턴
		{
			 1,	-1,	-1,	-1, -1,	-1,	-1,
			 1,	-1,	 1,	-1,	-1,	-1, -1,
			 1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	-1,	-1,	 1,	-1,	 1, -1,
			 1,	 1,	 1,	 1,	 1,	-1,  1
		},

		// [4] ㄴ 과 흡사한 패턴
		{
			-1,	 1,	-1,	-1, -1,	-1,	-1,
			 1,	-1,	-1,	-1,	-1,	-1,  1,
			 1,	 1,	-1,	-1,	-1,	-1, -1,
			 1,	-1,	 1,	 1,	-1,	-1,  1,
			 1,	 1,	 1,	 1,	 1,	 1,  1
		},

		// [5] ㄹ 과 흡사한 패턴
		{
			 1,	 1,	-1,	 1,  1,	 1,	 1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			 1,	 1,	-1,	 1,	 1,	 1,  1,
			 1,	 1,	-1,	-1,	-1,	-1, -1,
			 1,	 1,	 1,	 1,	 1,	-1,  1
		},

		// [6] ㄹ 과 흡사한 패턴
		{
			 1,	 1,	-1,	 1,  1,	 1,	-1,
			 1,	-1,	-1,	-1,	-1,	 1,  1,
			-1,	-1,	 1,	 1,	 1,	 1, -1,
			-1,	 1,	-1,	-1,	-1,	-1, -1,
			-1,	-1,	 1,	 1,	 1,	 1,  1
		},

		// [7] ㅋ 과 흡사한 패턴
		{
			 1,	 1,	 1,	 1,  1,	 1,	 1,
			-1,	-1,	-1,	-1,	 1,	-1,  1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
			 1,	 1,	-1,	 1,	-1,	 1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1
		},

		// [8] ㅋ 과 흡사한 패턴
		{
			 1,	 1,	 1,	 1, -1,	 1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			 1,	 1,	-1,	 1,	 1,	 1, -1,
			-1,	 1,	 1,	-1,	-1,	 1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1
		},

		// [9] ㅍ 과 유사한 패턴
		{
			 1,	 1,	 1,	 1,  1,	 1,	 1,
			-1,	 1,	-1,	-1,	 1,	 1, -1,
			-1,	 1,	 1,	-1,	-1,	 1, -1,
			-1,	 1,	 1,	-1,	 1,	 1, -1,
			 1,	-1,	 1,	 1,	 1,	-1,  1,
		},

		// [10] ㅍ 과 유사한 패턴
		{
			 1,	 1,	-1,	 1,  1,	-1,	 1,
			-1,	 1,	 1,	-1,	-1,	 1, -1,
			-1,	 1,	 1,	-1,	 1,	 1, -1,
			 1,	 1,	-1,	-1,	 1,	 1,  1,
			 1,	-1,	 1,	 1,	 1,	 1,  1,
		}

/*
		// [9] ㅌ과 유사한 패턴
		 {
			-1,  1,  1,  1,  1,  1, 1,
			 1,  1,  1, -1, -1, -1,-1,
			 1,  1,  1,  1,  1,  1, 1,
			 1,  1,  1,  1, -1, -1,-1,
			 1,  1,  1,  1,  1,  1, 1
		 },
		
		// [10] ㅌ과 유사한 패턴
		{
			-1,	 1,	 1,	 1,  1,	 1,	-1,
			 1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
			 1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	 1,	-1,	 1,	 1,	-1,  1
		}
*/
#if 0
		// 신기한 모양
		// [2] ㄱ 과 흡사한 패턴
		{
			 1,	 1,	 1,	-1,  1,	 1,	 1,
			 1,	-1,	 1,	 1,	 1,	 1, -1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	 1,  1,
			-1,	-1,	-1,	-1,	-1,	-1, -1
		}
#endif

#if 0
		// 역 ㅌ
		// [2] ㄱ 과 흡사한 패턴
		{
			 1,	-1,	-1,	-1,  1,	 1,	 1,
			 1,	 1,	-1,	 1,	 1,	-1, -1,
			 1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	 1,	-1,	-1,	-1, -1
		},
#endif

#if 0
		// [2] ㄱ 과 흡사한 패턴
		// 최종 출력 패턴 : 역ㄹ
		{
			 1,	-1,	-1,	-1,  1,	 1,	 1,
			 1,	 1,	 1,	 1,	 1,	 1, -1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	-1,	-1,	-1,	-1,  1,
			-1,	-1,	 1,	-1,	-1,	-1, -1
		}
#endif
		
#if 0
		// 입력 : 역 ㄱ
		// 출력 : 역 ㅋ
		{
			-1,	-1,	-1,	-1, -1,	-1,	-1,
			 1,	 1,	 1,	 1,	 1,	 1, -1,
			 1,	 1,	 1,	 1,	 1,	 1, -1,
			 1,	 1,	 1,	 1,	 1,	 1, -1,
			 1,	 1,	 1,	 1,	 1,	 1, -1
		},
#endif
		
#if 0
		// 입력 : 역 ㄴ
		// 출력 : 역 ㄴ
		{
			-1,	 1,	 1,	 1,  1,	 1,	 1,
			-1,	 1,	 1,	 1,	 1,	 1,  1,
			-1,	 1,	 1,	 1,	 1,	 1,  1,
			-1,	 1,	 1,	 1,	 1,	 1,  1,
			-1, -1,	-1,	-1,	-1,	-1, -1
		},
#endif

#if 0
		// 입력 : 역 ㄹ
		// 출력 : 역 ㄹ
		{
			-1,	-1,	-1,	-1, -1,	-1,	-1,
			 1,	 1,	 1,	 1,	 1,	 1, -1,
			-1,	-1,	-1,	-1,	-1,	-1, -1,
			-1,	 1,	 1,	 1,	 1,	 1,  1,
			-1, -1,	-1,	-1,	-1,	-1, -1
		},
#endif
		
#if 0
		// 입력 : 역 ㅋ
		// 출력 : 역 ㅋ
		{
			-1,	-1,	-1,	-1, -1,	-1,	-1,
			 1,	 1,	 1,	 1,	 1,	 1, -1,
			-1,	-1,	-1,	-1,	-1,	-1, -1,
			 1,	 1,	 1,	 1,	 1,	 1, -1,
			 1,  1,	 1,	 1,	 1,	 1, -1
		},
#endif

#if 0
		// 입력 : 역 ㅌ
		// 출력 : 역 ㄹ
		{
			-1,	-1,	-1,	-1, -1,	-1,	-1,
			-1,	 1,	 1,	 1,	 1,	 1,  1,
			-1,	-1,	-1,	-1,	-1,	-1, -1,
			-1,	 1,	 1,	 1,	 1,	 1,  1,
			-1, -1,	-1,	-1,	-1,	-1, -1,
		}
#endif
		
#if 0
		// 입력 : 전체 1
		{
			 1,	 1,	 1,	 1,  1,	 1,	 1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
			 1,	 1,	 1,	 1,	 1,	 1,  1,
			 1,  1,	 1,	 1,	 1,	 1,  1,
		}
#endif
	};

	// OutPat 초기화
	int OutPat[patterns][nodes] = { 0 };

	CalOutPat(OutPat, InPat, W);

	for (int i = 0; i < patterns; i++)
		CheckOutPat(OutPat, i, W);

	// 입력 패턴 & 출력 패턴 출력
	for (int i = 0; i < patterns; i++)
	{
		printf("\t[[ %2d 번째 패턴 ]]\n\n", i+1);
		for (int j = 0; j < lines; j++)
		{
			int k = j * (nodes / lines);
			do
			{
				printf("%4d", InPat[i][k]);
				k++;
			} while (k % (nodes / lines) != 0);

			k = j * (nodes / lines);
			printf("    ");
			do
			{
				if (InPat[i][k] >= 0)
					printf("■");
				else
					printf("□");
				k++;
			} while (k % (nodes / lines) != 0);
			printf("\n");
		}
		printf("\n");

		for (int j = 0; j < lines; j++)
		{
			int k = j * (nodes / lines);
			do
			{
				printf("%4d", OutPat[i][k]);
				k++;
			} while (k % (nodes / lines) != 0);
			
			printf("    ");
			k = j * (nodes / lines);
			do
			{
				if (OutPat[i][k] >= 0)
					printf("■");
				else
					printf("□");
				k++;
			} while (k % (nodes / lines) != 0);
			printf("\n");

		}
		printf("\n");
	}
	return 0;
}

// OutPatterns 계산 ( 모든 입력 패턴에 대해 1번씩 출력 패턴 계산 )
int CalOutPat(int OutPat[][nodes], int InPat[][nodes], int W[][nodes])
{
	for (int i = 0; i < patterns; i++)
	{													// 각 i번째 패턴에 대해서
		for (int j = 0; j < nodes; j++)					// 출력 패턴 j번째 노드를 구할 때,
		{												 
			OutPat[i][j] = InPat[i][j];					// 입력 패턴의 j번째 노드 값을 출력 패턴에 대입합니다.
														 
			for (int k = 0; k < nodes; k++)				
			{											// 이후,
				OutPat[i][j] += InPat[i][k] * W[k][j];	// 입력 패턴의 k번째 노드 값과
			}											// 가중치 배열의 k행 j열 번째 노드 값의 곱을 다 더합니다.
		}
	}
	return 0;
};

// OutPattern 이 수렴하는지 검사
// 가중치를 통해 OutPattern을 냈을 때 패턴에 변화가 있으면 반복 (재귀)
int CheckOutPat(int OutPat[][nodes], int i, int W[][nodes])
{
		int InPat[nodes] = { 0 };
		SetOutPat(OutPat, i);					// 아웃패턴 초기화 ( 하드 리미팅 비선형 활성화 함수 대응 )
		for (int j = 0; j < nodes; j++)
		{										// 기존의 출력패턴을 입력패턴으로 쓰기 위해서
			InPat[j] = OutPat[i][j];			// 출력패턴을 입력패턴으로 복사합니다
		}										

		CalOutPat2(OutPat, i, InPat, W);		// OutPat 계산 ( i번째 패턴에 대해서만 계산 )
		
		for (int k = 0; k < nodes; k++)
		{										// 한 노드에 대해서
			if (OutPat[i][k] * InPat[k] < 0)	// OutPat(출력패턴)과 InPat(입력패턴)가 서로 부호가 다른 값이면
			{									// 즉, (양수 * 음수) 거나 (음수 * 양수)일 때처럼
				CheckOutPat(OutPat, i, W);		// 패턴에 변화가 생긴 경우 수렴할 때까지 재귀합니다.
				break;
			}
		}
}

void SetOutPat(int OutPat[][nodes],int i)
{
	for (int k = 0; k < nodes; k++)
	{											// 아웃패턴 초기화 ( 하드 리미팅 비선형 활성화 함수 대응 )
		if (OutPat[i][k] >= 0)					// 0 이상이면 1로 설정하고,
			OutPat[i][k] = 1;
		else
			OutPat[i][k] = -1;					// 0 미만이면 -1로 설정합니다.
	}
	
#if 0	
	// SetOutPat 값 확인용 코드
	int a = 0;
	for (int b = 0; b < lines; b++)
	{
		a = b * (nodes/lines);
		do{
			printf("%4d", OutPat[i][a]);
			a++;
		} while (a % (nodes / lines) != 0);
		printf("   ");
		a = b * (nodes / lines);
		do {
			if (OutPat[i][a] >= 0)
				printf("■");
			else
				printf("□");
			a++;
		} while (a % (nodes / lines) != 0);

		printf("\n");
	}
	system("pause");
#endif
}

// i 번째 패턴에 대해서 다시 출력 패턴 계산
int CalOutPat2(int OutPat[][nodes], int i, int InPat[nodes], int W[][nodes])
{
	for (int j = 0; j < nodes; j++)
	{
		OutPat[i][j] = InPat[j];
		for (int k = 0; k < nodes; k++)
		{
			OutPat[i][j] += InPat[k] * W[k][j];
		}
	}
}

#endif
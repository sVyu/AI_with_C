
52장의 카드 -> 64가 2^6 이므로
                     2의 5, 4, 3, 2, 1, 0 승으로 표현 가능
		ㄴ 6자리
		ㄴ 6자리 x 카드 5장 = 30 자리
20 chromosome
Card[20][30]

최초 초기화 -> 랜덤
	        ㄴ Binary ( 0, 1 )
	        ㄴ [ 1~ 52 ] x 5
		52, 52, 52, 52 52,

52를 넘어가는 숫자면 0점,
이거를 차라리 0 ~ 51 만들고 1더해서
1 ~ 52 만든 다음에,
2진수로 변환해서 0, 1로 초기화..?
그러면 mutation 발생 시에는..?
차라리 52 넘어가면 0점으로 set
등록되지 않은 카드 사용으로 간주 ~

MergeSort	오름차순 구현
(따지고 보면 5개의 숫자로 이루어진 배열set,,)
(배열이 작은데 SelectionSort를 쓸까?)

정렬되어있는 상태로
카드 패 판별 함수 ( 별도 구현 )
하이 카드 < 원 페어5 < 투 페어10 < 트리플 <
스트레이트20 < 플러시25 < 풀하우스 < 포카드 <
스트레이트 플러시40 < 로얄 플러시 46
검사를 밑 단계부터 할 경우,,
비효율적 + 오류를 범할 수 있음
위에서부터 아래로 시행

스페이드 다이아 하트 클로버
클로버 < 하트 < 다이아몬드 < 스페이드
0~12    13~25      26~38        39 ~ 51

13으로 나누고 몫은 따로 저장
나머지 값을 사용해서 구분

룰렛 휠로 (점수 높은) 부모 6 set 고르고
운 좋은 부모 6set 고르고
자식 6set 만들고
새로운 2set 만들고 -> 초기화 함수 재활용

onepoint crossover ? 음.. 이게 더 꼬일 듯
multipoints crossover ( 복수점 교배 )
why ? 카드를 통으로 바꾸는게 맞으니까 ~
(mutation 은 1% 이하)

다시 검사 -> 부모 선정 -> 교배 -> 다음 세대
반복 ~~

종료조건 ?
음 ~ 20개중에 최댓값을 가진 배열이
	       15개 이상이면 종료
